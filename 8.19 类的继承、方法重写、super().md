# python3-
## 一、关于继承、方法重写、super()

          # -*- coding: utf-8 -*-  
          # @Author  : GaoTengFei 
          # @Time    : 2022/8/19 8:53
          # @File    : 继承.py
          # @Software: PyCharm
      
    
    class Person:
         def __init__(self, name, age):   #init需要self
           self.name = name
           self.age = age

       def __str__(self):
           return "name:{},age:{}\n".format(self.name, self.age)


     class Student(Person):
        def __init__(self, name, age, phonum):
           super().__init__(name, age)    #继承父类属性
           self.phonum = phonum

       def __str__(self):                 #重写
            return "name:{},age:{},phonum:{}\n".format(self.name, self.age, self.phonum)


     class Xuesheng(Student):
        def __init__(self, name, age, phonum, year):
            super(Xuesheng, self).__init__(name, age, phonum)
            self.year = year

        def __str__(self):
            return "name:{},age:{},phonum:{},year:{}\n".format(self.name, self.age, self.phonum, self.year)


     if __name__ == '__main__':
       x = Person("gao", 21)
       y = Student("zhang", 22, 13233056865)
       z = Xuesheng("guo", 23, 13233056865, 2019)
       print(x, y, z)
       

输出结果：

          name:gao,age:21
          name:zhang,age:22,phonum:13233056865
          name:guo,age:23,phonum:13233056865,year:2019

## 二、迭代器iter、__iter__、__next__

**列表、元组、字典和集合**都是可迭代的对象。它们是可迭代的容器，您可以从中获取迭代器（Iterator）。所有这些对象都有用于获取迭代器的 iter() 方法：

从元组返回一个迭代器，并打印每个值：

                    mytuple = ("apple", "banana", "cherry")
                    myit = iter(mytuple)

                    print(next(myit))
                    print(next(myit))
                    print(next(myit))

### 遍历迭代器
我们也可以使用 for 循环遍历可迭代对象：

迭代元组的值：

          mytuple = ("apple", "banana", "cherry")

          for x in mytuple:
                    print(x)


### 创建迭代器

要把对象/类创建为迭代器，必须为对象实现 __iter__() 和 __next__() 方法。

正如您在 Python 类/对象 一章中学到的，所有类都有名为 __init__() 的函数，它允许您在创建对象时进行一些初始化。

__iter__() 方法的作用相似，您可以执行操作（初始化等），但必须始终返回迭代器对象本身。

__next__() 方法也允许您执行操作，并且必须返回序列中的下一个项目。

### StopIteration

如果你有足够的 next() 语句，或者在 for 循环中使用，则上面的例子将永远进行下去。

为了防止迭代永远进行，我们可以使用 StopIteration 语句。

在 __next__() 方法中，如果迭代完成指定的次数，我们可以添加一个终止条件来引发错误：

          class MyNumbers:
            def __iter__(self):
              self.a = 1
              return self

            def __next__(self):
              if self.a <= 20:
                x = self.a
                self.a += 1
                return x
              else:
                raise StopIteration

          myclass = MyNumbers()
          myiter = iter(myclass)

          for x in myiter:
            print(x)

## 总结
1. super().__init__()需要继承父类所有属性
2. 方法重写的时候要加self
