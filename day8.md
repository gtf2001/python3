### 内嵌函数和闭包

- 内嵌函数

~~~markdown
形式上：一个函数里面又定义了一个函数
		外层的函数：外部函数
		内层的函数：内部函数
1. 内嵌函数的作用范围：同局部变量
	在作用域以外是不能被调用的
	作用范围：从代码块开始到结束
2. 内嵌函数不能执行类似于a+=1的操作
	本质：等号右边先进行使用，然后左边再进行赋值
	解决方案：nonlocal或者global
~~~

- 闭包

~~~markdown
全称：词法闭包 Lexical Closure
是一种编程范式：对代码进行提炼和概括，使得代码的重用性更高。
~~~

~~~markdown
闭包的条件
1. 必须是一个内嵌函数
2. 外部函数必须返回的是内部函数的函数对象
3. 内部函数必须引用外部函数的局部变量
~~~

- 闭包的作用

~~~markdown
1. 可以在声明较少的参数的情况下，传递更多的参数
2. 可以使用更多的内部函数
		间接使用：通过return 返回出内部函数的函数对象（尚未被调用），然后再使用
3. 多用于集群
~~~

- 闭包的优势

~~~markdown
1. 避免使用全局变量
	全局变量容易出现脏读问题（不安全）
2. 提供部分的数据隐藏
	1. 隐藏了参数
	2. 隐藏了内部函数对象
3. 可以更优雅的实现面向对象
	返回了一个函数对象
~~~

- 匿名函数

~~~markdown
没有函数名的函数
1. 临时使用一次
2. 函数只是用一次

可以避免命名冲突
关键字：lambda
语法：
	lambda 形参:返回值
	
1. lambda 用于创建一个lambda函数对象
2. lambda书写的形式：lambda表达式
3. lambda表达式常常应用与泛函编程（编程范式）
4. lambda表达式是一种解析式
		通过解析来创建函数对象
		执行效率相对来说较高
5. lambda表达式的优先级最低
~~~

- lambda表达式的作用

~~~markdown
1. 可以避免使用函数名，使用方便，代码更加简洁，优雅
2. 代码相对简化，可以适当地提高代码的可读性
~~~

### 高级函数

- 函数式编程

~~~markdown
1. 也称之为泛函编程，是一种编程范式：
	可以将一个函数对象作为参数传递给另一个函数，被传入的函数对象的执行过程，在调用的函数中执行
2. 函数式编程的重要基础是lambda表达式
	lambda表达式可以返回一个函数对象
~~~

- filter()

~~~markdown
python2：函数
python3：类
filter:过滤器
filter(function or None,iterable)
function：一个函数
iterable：可迭代对象
1. 如果function给出，将可迭代对象中的每一个元素，都挨个传递给function作为参数，筛选出return为True值
2. 如果function没有给出，一定要填None，则直接返回iterable中的为True的值

真值：任何非零的值
假值：任何零、None、空
[],(),{},'',0,False,0.0,0.,.0
~~~

- map()

~~~markdown
python2：函数
python3：类
map：映射
	map(func, *iterables)
		func:函数
		iterables：可迭代对象
		运算iterables多个可迭代对象，将多个可迭代对象的对应的相同下标的元素，作为参数传递给func，返回一个map对象，map中每个元素为：相同下标根据func运算后的结果。当最短的可迭代对象执行完毕，则停止运算。
		
		func中的形参的个数，必须匹配可迭代对象的个数
~~~

实例：

```python
l1 = [1,2,3]
l2 = [1,2,3,4,5,6]
print(list(map(lambda x,y: x+y,l1, l2)))
```

输出结果：

[2, 4, 6]

- reduce()

~~~markdown
python2：内置函数
python3：函数，functools之下
reduce：折叠
	1. reduce(function, sequence, initial=_initial_missing)
		1. 将序列中的前两个元素传入给function作为参数
		2. function将计算出的结果和序列中的下一个元素，作为新的两个参数，重新传递给function，以此类推
		3. 最终得到一个结果（最终的数值）
		4. 如果设置了initial，则先传入initial和序列的第一个元素，给function
~~~

实例：

```python
import functools
l2 = [1,2,3,4,5,6]
print(functools.reduce(lambda x,y: x+y,l2,100))
```

输出结果：

121

### 函数的嵌套调用和？？

- 函数的嵌套调用

~~~markdown
1. 一个函数里面调用另一个函数，函数的嵌套调用
	两个函数之间有没有关系：没有必然的联系
	1. 分别属于两个不同的函数
	2. 内嵌函数
	3. 自己调用自己
~~~

- 使用函数的必要性

~~~markdown
1. 重复使用的代码，抽取出来，封装成函数
2. 拥有特殊功能的代码抽取出来，封装为函数，解耦合
3. 简化开发流程
f(x) = 0
~~~

$f(x) = ax^2+bx+c$ 

- 函数的递归

~~~markdown
1. 函数的嵌套使用：一个函数调用量另一个函数
2. 函数的递归使用：一个函数调用自己

1. 注意：避免无穷递归
	解决方案：控制好递归的边界。通过return来终止流程。
2. 递归异常：
	RecursionError: maximum recursion depth exceeded while calling a Python object
3. 报错的原因：
	执行原理：函数的无穷递归区别于死循环
	循环：代码块级别---在同一个代码块中无限的执行，占用的空间永远是一个代码块的空间，只不过是重复执行罢了。
	递归：对象级别---对象的内存占用量是远大于一个代码块。每一次的递归都会创建一个新的对象，内存就会无限累加使用---无限递归会发生内存溢出。
	小结：循环消耗小，递归消耗较大
	直接原因：超过了最大深度
	python为了保护系统的内存，设置了递归的层数，如果超过层数，则会报错。
4. 递归的使用:
	1. 将大问题分解为小问题，如果一个大问题的解决方案和一个小问题的解决方案一样，那么只需要解决小问题，大问题则迎刃而解。
	2. 递归的效率很低，一般用于解决难题。
	3. 尽量不要使用递归，能用递归解决的问题一定可以用循环解决。
~~~































